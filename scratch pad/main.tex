\documentclass[12pt]{amsart}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
\usepackage[algoruled]{algorithm2e}
% Default style choices include plain, plainruled, boxed, ruled, algoruled, boxruled and tworuled.
% \geometry{landscape} % rotated page geometry

% See the ``Article customise'' template for come common customisations

\title{}
\author{}
\date{} % delete this line to display the current date

%%% BEGIN DOCUMENT
\begin{document}

\maketitle

\section*{Packing Coloring on full $3$-degree tree}

\begin{algorithm}
	\caption{\textsc{Packing Coloring on Full Binary Tree}}
	
	Color Every odd layer with color $1$.

	\For{Every Layer $l \in \{2, 4, 6, \dots\}$}{
		\uIf{$l = 2$}{
			Color left vertex with $2$\;
			Color right vertex with $3$\;
		} \ElseIf{$l = 4$}{
			\If{Grand Parent Color = $2$}{
				Color children with $3,4,3,5$\;
			} \ElseIf{Grand Parent Color = $3$} {
				Color children with $2, 4, 2, 5$\;
			}
		}

		\BlankLine

		/* For other layers lower than $4$ */

		\If{Grand Parent Color $\in \{4,5,6,7\}$}{
			Color children with $2,3,2,3$\;
			\textsf{GOTO next node}\;
		}

		\BlankLine

		\If{Grand Parent Color is $3$ or $2$} {
			$x \gets$ grandparent node\;

			\uIf{color$(x) = 3$} {
				Color each left grand-childern with $2$\;
			}\ElseIf{color$(x) = 2$} {
				Color each left grand-childern with $3$\;
			}

			$(u_1,u_2, u_3), x, (v_1,v_2,v_3)$ is a triplet $u_j, v_j$ are left and right siblings of $x$\;

			\BlankLine
			$u_j,v_j \gets \phi$ if there is none exists, if either is $\phi$ ignore\;
			$C \gets$ visit each $u_i, v_i$ upto distance $7$ to find an un-used color\;

			\BlankLine
			Color node with $C$\;
		}
	}

	\textbf{Output} Coloring\;

\end{algorithm}

\newpage

\section*{Two Pass Strategy}

\begin{algorithm}
	\caption{\textsc{Two Pass Strategy}}
	
	Activated $\gets \phi$\;
	
	\For{Every event $(k, v_k)$}{
		$v(k) = v_k$\;
		\For{$\forall j \in$ fanout of $k$} {
			Update the value of j\;
			Activated $\gets$ Activated $\cup$ $\{j\}$\;
		}
	}
	
	\For{$j \in$ Activated} {
		\Begin{
			$v' = $ evaluate($j$)\;
			\If{$v' \neq lsv(j)$} {
				add event $(j, v')$ to the event list at time $t + d(j)$\;
				$lsv(j) = v'$\;
			}
		}
	}

\end{algorithm}

\newpage

\section*{One Pass Strategy}

\begin{algorithm}
	\caption{\textsc{One Pass Strategy}}
	
	\For{Every event $(k, v_k)$}{
		$v(k) = v_k$\;
		\For{$\forall j \in$ fanout of $k$} {
			Update the value of j\;
			
			Instead of putting $j$ to activated set, process it here\;
			\Begin{
				$v' = $ evaluate($j$)\;
				\If{$v' \neq lsv(j)$} {
					add event $(j, v')$ to the event list at time $t + d(j)$\;
					$lsv(j) = v'$\;
				}
			}
		}
	}

\end{algorithm}

\section*{One Pass Strategy With Zero-Width Spikes}

\begin{algorithm}
	\caption{\textsc{One Pass Strategy With Zero-Width Spikes}}
	
	\For{Every event $(k, v_k)$}{
		$v(k) = v_k$\;
		\For{$\forall j \in$ fanout of $k$} {
			Update the value of j\;
			
			Instead of putting $j$ to activated set, process it here\;
			\Begin{
				$v' = $ evaluate($j$)\;
				
				\If{$v' \neq lsv(j)$} {
					$t' = t + d(j)$\;
				
					\If{$t' = lst(j)$}{
						cancel event $(j, lsv(j))$ at time $t'$\;
					}
					
					add event $(j, v')$ to the event list at time $t + d(j)$\;
					$lsv(j) = v'$\;
					$lst(j) = t'$\;
				}
			}
		}
	}

\end{algorithm}



\end{document}